// Code generated by mockery v2.15.0. DO NOT EDIT.

package events

import (
	aggregatesv1 "github.com/jgkawell/galactus/api/gen/go/core/aggregates/v1"
	context "github.com/jgkawell/galactus/pkg/chassis/context"

	logging "github.com/jgkawell/galactus/pkg/logging"

	messagebus "github.com/jgkawell/galactus/pkg/chassis/messagebus"

	mock "github.com/stretchr/testify/mock"

	v1 "github.com/jgkawell/galactus/api/gen/go/generic/events/v1"
)

// MockEventManager is an autogenerated mock type for the EventManager type
type MockEventManager struct {
	mock.Mock
}

// CreateAndSendEvent provides a mock function with given fields: ctx, event, aggregateId, aggregateType, eventType, eventCode
func (_m *MockEventManager) CreateAndSendEvent(ctx context.ExecutionContext, event interface{}, aggregateId string, aggregateType v1.AggregateType, eventType v1.EventType, eventCode string) logging.Error {
	ret := _m.Called(ctx, event, aggregateId, aggregateType, eventType, eventCode)

	var r0 logging.Error
	if rf, ok := ret.Get(0).(func(context.ExecutionContext, interface{}, string, v1.AggregateType, v1.EventType, string) logging.Error); ok {
		r0 = rf(ctx, event, aggregateId, aggregateType, eventType, eventCode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(logging.Error)
		}
	}

	return r0
}

// GetEventAndMessageData provides a mock function with given fields: logger, msg
func (_m *MockEventManager) GetEventAndMessageData(logger logging.Logger, msg messagebus.Message) (*aggregatesv1.Event, []byte, logging.Error) {
	ret := _m.Called(logger, msg)

	var r0 *aggregatesv1.Event
	if rf, ok := ret.Get(0).(func(logging.Logger, messagebus.Message) *aggregatesv1.Event); ok {
		r0 = rf(logger, msg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*aggregatesv1.Event)
		}
	}

	var r1 []byte
	if rf, ok := ret.Get(1).(func(logging.Logger, messagebus.Message) []byte); ok {
		r1 = rf(logger, msg)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}

	var r2 logging.Error
	if rf, ok := ret.Get(2).(func(logging.Logger, messagebus.Message) logging.Error); ok {
		r2 = rf(logger, msg)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(logging.Error)
		}
	}

	return r0, r1, r2
}

// ThrowSystemError provides a mock function with given fields: ctx, event, aggregateId, systemError
func (_m *MockEventManager) ThrowSystemError(ctx context.ExecutionContext, event interface{}, aggregateId string, systemError *v1.SystemError) {
	_m.Called(ctx, event, aggregateId, systemError)
}

type mockConstructorTestingTNewMockEventManager interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockEventManager creates a new instance of MockEventManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockEventManager(t mockConstructorTestingTNewMockEventManager) *MockEventManager {
	mock := &MockEventManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
